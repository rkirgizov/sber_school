1. Красивый вывод

Вам дан набор данных о бронированиях со следующими полями:
1. book_ref - номер бронирование
2. book_date - дата бронирования
3. total_amount - цена (c копейками)
Необходимо вывести эти данные в красивом формате:
Номер бронирования ХХХ, забронирован YYYY. Цена: M руб. N коп.

count = int(input())
for i in range(count):
    [book_ref, book_date, total_amount] = input().split(',') 
    [rubles, cops] = total_amount.split('.')
    print(f'Номер бронирования {book_ref}, забронирован {book_date}. Цена: {rubles} руб. {cops} коп.')

2. Вещественное сравнение

Необходимо реализовать функцию is_bigger(num1, num2, eps).
Эта функция принимает 3 параметра:
1. num1 - первое вещественное число
2. num2 - второе вещественное число
3. eps - эпсилон (вещественное число).
Эта функция возвращает логическое True, если число num1 больше или равно num2 хотя бы на епсилон. 
В противном случае она должна вернуть логическое False.

def is_bigger(num1, num2, eps):
    if num1 >= (num2+eps):
        return True
    else:
        return False

3. Неоднородные данные

Есть набор данных о посадочных талонах, который поступают от разных подрядчиков.
Поэтому сами данные неоднородны.
Вам необходимо реализовать логику, которая приведет все данные к одному формату.
Входные данные представляют собой список следующих полей:
1. ticket_no
2. flight_id
3. boarding_no
4. seat_no
Ниже указано то, какие данные могут быть в каждом из полей и как это поле нужно преобразовать.
Поле ticket_no всегда содержит строчку, а поле flight_id всегда содержит число.
Возможные значения boarding_no:
1. Строчка, начинающееся с "Номер:"
2. Строчка (начинается не с "Номер:")
Необходимо все значения привести к строчке, без начала "Номер:"
Возможные значения seat_no:
1. Ряд и место, разделенные символом ";"
2. Ряд и место слитно
Необходимо все значения привести к написанию, через точку с запятой (символ ";").
Ряд - это целое число от 1 до 299. Число пишится без ведущих нулей - 1, а не 01.
Место - это буква от "A" до "H"

count = int(input())
for i in range(count):
    [ticket_no, flight_id, boarding_no, seat_no] = input().split(',') 
    if boarding_no[:6] == 'Номер:':
        boarding_no = boarding_no[6:]
    if seat_no.find(';') == -1:
        seat_no = seat_no[:-1] + ';' + seat_no[-1:]
    print (','.join([ticket_no, flight_id, boarding_no, seat_no]))
	
4. Дубликаты

К сожалению, обнаружилось, что в данных о посадочных талонах есть дубликаты (повторяющиеся значения).
Дубликатом считаются строки, у которых одинаковы одновременно поля ticket_no и flight_id.
Необходимо убрать дубликаты строк и оставить только первые вхождения.
Порядок записей менять не надо.
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном талоне.
Порядок полей в строчке: ticket_no, flight_id, boarding_no, seat_no.
Все поля разделены одной запятой. В самих данных запятых нет.
Формат выходных данных
Необходимо вывести все исходные строчки, без дубликатов.
В каждой строчке записаны исходные поля ticket_no, flight_id, boarding_no, seat_no.
Все поля разделены одной запятой.

count = int(input())
talons = []
for i in range(count):
    talons.insert(i,input())

printed_talons = []
for i in range(len(talons)):
    a = talons[i].find(',', talons[i].find(',') + 1)
    count = 0
    for j in range (len(printed_talons)):
        if talons[i][:a] in printed_talons[j]:
            count += 1        
    if count < 1:
        printed_talons.insert(i,talons[i])
        print(talons[i])

5. Популярный рейс

Необходимо найти идентификатор самого популярного рейса.
Другими словами - тот flight_id, который встречался наибольшее количество раз во входных данных.
Если таких рейсов несколько, то необходимо вывести их все на одной строке через пробел в порядке возрастания их значения.
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном талоне.
Порядок полей в строчке: ticket_no, flight_id, boarding_no, seat_no.
В поле flight_id записано целое число больше 0.
Все поля разделены одной запятой. В самих данных запятых нет.
Формат выходных данных
Одна строчка, содержащая все flight_id для самых популярных рейсов.
Flight_id разделены пробелом и идут в порядке возрастания значения (как числа).

count = int(input())
talons = []
for i in range(count):
    talons.insert(i,input())
flight_ids_dict = {}
for i in range(len(talons)):
    flight_id = talons[i].split(',')[1]
    count = 0
    for j in range (len(talons)):
        if flight_id == talons[j].split(',')[1]:
            count += 1 
    flight_ids_dict[flight_id] = count
maxvalue = max_val = max(flight_ids_dict.values())
sorted_ids = []
for k, v in flight_ids_dict.items():
    if v == maxvalue:
        sorted_ids.append(int(k))
print(*sorted(sorted_ids))

6. Фильтрация

Задан набор flight_id, которые интересуют нас для дальнейшей работы.
Необходимо отфильтровать исходный набор данных по этим flight_id.
Другими словами вывести только те записи, у которых flight_id один из интересующих (см. формат входных данных).
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записаны интересующие flight_id, разделенные запятой.
На второй строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном талоне.
Порядок полей в строчке: ticket_no, flight_id, boarding_no, seat_no.
Все поля разделены одной запятой. В самих данных запятых нет.
Формат выходных данных
Необходимо вывести те строчки, чьи flight_id подходят под условие.
Порядок строк оставить такой же, как и во входных данных.

filter_ids = input().split(',')
count = int(input())
talons = []
for i in range(count):
    talons.insert(i,input())
for i in range(len(talons)):
    flight_id = talons[i].split(',')[1]
    if flight_id in filter_ids:
        print(talons[i])

7. Группировка

Вам дана информация о посадочных талонах.
Необходимо сгруппировать данные по вылетам - для каждого рейса определить, какие места были куплены.
Более формально: для одного flight_id собрать все возможные seat_no.
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном талоне.
Порядок полей в строчке: ticket_no, flight_id, boarding_no, seat_no.
Поле flight_id содержит натуральное число.
Поле seat_no содержит номер места.
Все поля разделены одной запятой. В самих данных запятых нет.
Формат выходных данных
Пары строк - на первой строке очередной flight_id, а на второй строке все seat_no через запятую.
Выводить flight_id необходимо по возрастанию (как числа).
Номера мест seat_no внутри одного рейса оставить таким же, как и во входных данных.
Примечание
Обратите внимание, что строчки и числа сравниваются по-разному.
Так, например, строка "3" больше строчки "10".
Иными словами в ответе должно быть 3,10 вместо "10","3".

count = int(input())
talons = []
for i in range(count):
    talons.insert(i,input())
groups = []
for i in range(len(talons)):
    flight_id = int(talons[i].split(',')[1])
    if flight_id not in groups:
        groups.append(flight_id)
groups = sorted(groups)
for i in range(len(groups)):
    print(groups[i])    
    string = ''
    for j in range(len(talons)):
        flight_id = int(talons[j].split(',')[1])
        seat_no = talons[j].split(',')[3]
        if flight_id == groups[i]:
            if string == '':
                string = ''.join([string, seat_no])
            else:
                string = ','.join([string, seat_no])
    print(string)

8. Общие идентификаторы

Обнаружилось, что несколько аналитиков продублировали работу друг друга.
Теперь нужно понять, какие рейсы обработали несколько раз.
Вам дано несколько наборов идентификаторов рейсов (набор flight_id). 
Необходимо определить те идентификаторы, которые присутствуют в каждом наборе. 
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат выходных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны идентификаторы тех рейсов, которые обработал очередной аналитик.
На одной строчке все идентификаторы записаны через запятую. В самих данных запятых нет.
Каждый идентификатор рейса (flight_id) - это натуральное число.
Формат выходных данных
Одна строчка. Выведите все общие идентификаторы в порядке возрастания их значения (как числа).
В качестве разделителя используйте запятую.
Примечание
Обратите внимание, что строчки и числа сравниваются по-разному.
Так, например, строка "3" больше строчки "10".
Иными словами в ответе должно быть 3,10 вместо "10","3".

count = int(input())
input_ids = []
for i in range(count):
    input_ids.insert(i,input())
repeated_ids = {}
for i in range(len(input_ids)):
    count = 0
    list = input_ids[i].split(',')
    for j in range (len(list)):
        if list[j] in repeated_ids.keys():
            repeated_ids[list[j]] = repeated_ids.get(list[j]) + 1
        else:
            repeated_ids[list[j]] = 1
ids = []
for k, v in repeated_ids.items():
    if v == len(input_ids):
        ids.append(int(k))
sorted_ids = sorted(ids)
string = ''
for i in range(len(sorted_ids)):
    if string == '':
        string = str(sorted_ids[i])
    else:
        string = string+','+str(sorted_ids[i])
print(string)

9. Полеты по расписанию

Вам даны данные о рейсах:
1. scheduled_departure - Время вылета по расписанию
2. scheduled_arrival - Время прилёта по расписанию
3. actual_departure - Фактическое время вылета
4. actual_arrival - Фактическое время прилёта
Считается, что самолет выполнил рейс по расписанию, если фактическое время отличаются меньше, чем на 30 минут от времени по расписанию (надо учитывать разницу как для вылета, так и прилета). 
Другими словами и для вылета и для прилета разница во времени должна быть меньше, чем 1800 секунд.
Определите по данным, успел ли совершиться полет по расписанию.
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном полете.
Порядок полей в строчке: scheduled_departure, scheduled_arrival, actual_departure, actual_arrival.
Все поля разделены одной запятой. В самих данных запятых нет.
Время во всех полях записано в формате: ГГГГ-ММ-ДДTЧЧ:ММ
Формат выходных данных
N строчек. На каждой строчке Yes, если соответствующий рейс успел по расписанию и No наоборот.

from datetime import datetime
from datetime import timedelta
 
count = int(input())
input_list = []
for i in range(count):
    input_list.insert(i,input())

max_delay = 1800

td_delay = timedelta(seconds=1800)

for i in range(len(input_list)):
    scheduled_departure, scheduled_arrival, actual_departure, actual_arrival = input_list[i].split(',')
    scheduled_departure = datetime.strptime(scheduled_departure, "%Y-%m-%dT%H:%M")
    scheduled_arrival = datetime.strptime(scheduled_arrival, "%Y-%m-%dT%H:%M")
    actual_departure = datetime.strptime(actual_departure, "%Y-%m-%dT%H:%M")
    actual_arrival = datetime.strptime(actual_arrival, "%Y-%m-%dT%H:%M")
    
    delta_departure = abs(actual_departure - scheduled_departure)
    delta_arrival = abs(actual_arrival - scheduled_arrival)

    if delta_departure.seconds < max_delay and delta_arrival.seconds < max_delay:
        print('Yes')
    else:
        print('No')

10. Статистика рейсов

Статус рейса может принимать одно из следующих значений:
1. Scheduled. Рейс доступен для бронирования. Это происходит за 30 дней до плановой даты вылета; до этого запись о рейсе не существует в базе данных.
2. On Time. Рейс доступен для регистрации (за сутки до плановой даты вылета) и не задержан.
3. Delayed. Рейс доступен для регистрации (за сутки до плановой даты вылета), но задержан.
4. Departed. Самолет уже вылетел и находится в воздухе.
5. Arrived. Самолет прибыл в пункт назначения.
6. Cancelled. Рейс отменён.
Вам дан набор статусов для каждого из рейса. 
Необходимо посчитать статистику - сколько рейсов в каждом из статусов.
В этой задаче надо написать весь код самостоятельно (а не реализовывать какую-то конкретную функцию).
Решение должно само читать входные данные и писать ответ в заданном формате.
Формат входных данных
На первой строчке записано натуральное число N.
На последующих N строчках записаны данные об очередном рейсе.
Порядок полей в строчке: flight_id, status.
Поле flight_id содержит идентификатор рейса - натуральное число.
Поле status содержит статус рейса - строка, одно из 6 значений.
Все поля разделены одной запятой. В самих данных запятых нет.
Формат выходных данных
6 строчек. На каждой строчке - целое число, соответвующее количеству рейсов со статусом с таким же номером.
То есть на первой строчке - количество рейсов со статусом Scheduled, на второй - со статусом On Time и т.д.

count = int(input())
input_list = []
for i in range(count):
    input_list.insert(i,input())
statistic = {
    'Scheduled' : 0,
    'On Time'   : 0,
    'Delayed'   : 0,
    'Departed'  : 0,
    'Arrived'   : 0,
    'Cancelled' : 0,
}
for i in range(len(input_list)):
    status = input_list[i].split(',')[1]
    statistic[status] = statistic.get(status) + 1
for k, v in statistic.items():
    print(v)



























